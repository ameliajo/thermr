#include "catch.hpp"
#include "calcem/calcem_util/e_ep_mu_util/e_ep_mu.h"
#include <range/v3/all.hpp>
#include "generalTools/testing.h"
#include <range/v3/all.hpp>



/*

TEST_CASE( "do we need a midpoint" ){ 
  std::vector<double> x(20,0.0), y(20*65,0.0); 
  
  std::vector<double> beginningOfY { 195158.09939262934, -0.87238772679496734, -0.61817875518802279, -0.36545660682035069, -0.11418564421716945, 0.13568062577950979, 0.38420180765640111, 0.63141488906433418, 0.87738226704862166 };

  x[0] = 2.54E-3;
  
  for (size_t i = 0; i < beginningOfY.size(); ++i){ 
    y[i*x.size()+0] = beginningOfY[i]; 
  }



  double xm = 1.27e-3;
  std::vector<double> s { 235586.48147822541, -0.86806816809249565, -0.60677324533223020, -0.34926974510882292, -9.5577908119815064E-002, 0.15436521665672856, 0.40054354740949549, 0.64302993119542795, 0.88181200416435501, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  int i = 2;
  int nl = 9;
  double tol = 1.0;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == false );
  tol = 1e-2;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == true  );
  tol = 5e-1;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == true  );
  tol = 0.56;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == true  );
  tol = 0.59;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == false );


} // TEST CASE


*/

TEST_CASE( "do 330" ){ 
  std::vector<double> x(20,0.0), y(20*65,0.0); 
  
  std::vector<double> beginningOfY { 194040.33954861510, -0.74537422649273466, 
    -0.24002340213077786, 0.25973645751508195, 0.75430496529005719 };

  x[0] = 2.5607298E-3;
  double enow = 1e-5;
  
  for (size_t i = 0; i < beginningOfY.size(); ++i){ 
    y[i*x.size()+0] = beginningOfY[i]; 
  }

  int i = 2, lat = 0, iinc = 2, lasym = 0;
  double tev = 2.5507297687999999E-2, tol = 5.0000000000000003E-002;
  std::vector<double> alphas { 1.1, 2.2, 3.3, 4.5, 5.8 },
                       betas { 0.1, 0.2, 1.3, 1.4, 2.5, 2.6, 3.7 },
                       sab { -0.18259619, -0.30201347, -3.93654779, -3.98809174, -4.33545607, -4.39515402, -5.88934921, -0.76225291, -0.81658341, -3.14161459, -3.30566186, -3.90554652, -3.96233362, -5.23696660, -1.19182884, -1.23155471, -2.79610565, -2.95633099, -3.74989225, -3.80837585, -4.93373911, -1.58342860, -1.61310713, -2.71233943, -2.84291608, -3.69699590, -3.75199349, -4.77433858, -1.96121202, -1.98720663, -2.78454600, -2.88531460, -3.71288120, -3.77142141, -4.71158392 };
  double az = 0.99917, sigma_b = 163.72792237, sigma_b2 = 0.0, teff = 0.120441926;
  int nnl = -5, nl = 5;
  std::vector<double> p2(118,0.0), p3(118,0.0), xsi(99,0.0);
  double xlast = 0.0, ylast = 0.0;
  int jbeta = 1;
  int j = 0;

  do_330(enow,x,y,i,j,tev,tol,lat,iinc,lasym,alphas,betas,sab,az,sigma_b,sigma_b2,teff,nnl,nl,jbeta);


  std::vector<double> correctX {2.5607298000002560E-003, 1.9205474000001919E-003, 1.2803649000001280E-003, 3.2009123000003198E-004, 1.6004562000001597E-004, 8.0022810000007999E-005, 4.0011405000004000E-005, 2.0005703000001998E-005, 1.0002852000000999E-005, 5.0014260000005001E-006, 2.5007130000002501E-006, 1.2503565000001250E-006, 6.2517825000006252E-007, 3.1258913000003122E-007, 1.5629457000001563E-007, 7.8147285000007815E-008, 3.9073643000003909E-008, 1.9536822000001953E-008, 9.7684110000009766E-009, 0.0000000000000000};
  REQUIRE( ranges::equal(x,correctX,equal) );
  //std::cout << y[18] << "  " << y[19] << "  " << y[20] << std::endl;
  std::vector<double> correctPDF { 
194040.33954861510, 213357.44843514718, 234616.86137154896, 
270904.33815197728, 278088.30872238980, 281762.29414242797, 
284435.99384899955, 284849.72192457784, 281681.09445961961, 
201641.82282601038, 142771.26317315488, 100595.05501629552, 
71050.277403689135, 50112.447608311384, 35395.393815192023, 
25015.294877611741, 17684.033854318415, 12502.953328897038, 
8840.3806620390715, 0.0000000000000000 };

  for ( size_t i = 0; i < correctPDF.size(); ++i ){
    REQUIRE( correctPDF[i] == Approx(y[0*x.size()+i]).epsilon(1e-6) );
  }


  std::vector<double> mu1 {
-0.74537422649273466, -0.74224683558379401, -0.73752319714464698, 
-0.71588964028358915, -0.69921247602195746, -0.67683292016396035, 
-0.64495078330964928, -0.60219706321307387, -0.54631583456353605, 
-0.60195805566866123, -0.64428642180907281, -0.67560622181423446, 
-0.69722836065824800, -0.71298933652991459, -0.72392858529963555, 
-0.73159829221319150, -0.73699960812918153, -0.74081882393919452, 
-0.74350704856388461, 0.0000000000000000 };

  for ( size_t i = 0; i < mu1.size(); ++i ){
      REQUIRE( mu1[i] == Approx(y[1*x.size()+i]).epsilon(1e-6) );
  }


  std::vector<double> mu2 {
-0.24002340213077786,   -0.23307917120825550,   -0.22265027205525154, 
-0.17496084570875930,   -0.13820280066170179,   -8.9413946078666873E-2,
-2.0050560578183850E-2,  7.3792394901956840E-2,  0.19662745867658726,
7.4318225239288799E-2,  -1.8605026865589597E-2, -8.6724209989652065E-2,
-0.13381656649298104,   -0.16855131189449732,   -0.19263496473751643,
-0.20951361104305818,   -0.22139824626862689,   -0.22977689654268965,
-0.23570553096010322,    0.0000000000000000 };
  for ( size_t i = 0; i < mu2.size(); ++i ){
      REQUIRE( mu2[i] == Approx(y[2*x.size()+i]).epsilon(1e-6) );
  }


  std::vector<double> mu3 {
0.25973645751508195, 0.26675518332109810, 0.27722682519484065, 
0.32501092677830001, 0.36182433614945603, 0.40935137277239836, 
0.47693984838387143, 0.57404605791986019, 0.69651960489270925, 
0.57457245809224466, 0.47835921051938751, 0.41200900578317562, 
0.36623566875618518, 0.33145374850490605, 0.30736385039048941, 
0.29048520331321215, 0.27860108069770884, 0.27022259191298409, 
0.26430705987700520, 0.0000000000000000 };

for ( size_t i = 0; i < mu3.size(); ++i ){
      REQUIRE( mu3[i] == Approx(y[3*x.size()+i]).epsilon(1e-6) );
}



std::vector<double> mu4 { 
0.75430496529005719, 0.75749667719476355, 0.76231708175316237, 
0.78402829078121494, 0.80058801701189408, 0.82246747782324370, 
0.85304957576183960, 0.89694297747082763, 0.95281270117734307, 
0.89717900324972399, 0.85370066624101548, 0.82368524998613313, 
0.80256152506734102, 0.78695310561733234, 0.77605278663750588, 
0.76839486454227013, 0.76299762691129880, 0.75917946781505907, 
0.75647903546859263, 0.0000000000000000};
for ( size_t i = 0; i < mu4.size(); ++i ){
      REQUIRE( mu4[i] == Approx(y[4*x.size()+i]).epsilon(1e-6) );
}
for ( size_t i = 5*x.size(); i < y.size(); ++i){
      REQUIRE( 0.0 == Approx(y[i]).epsilon(1e-6) );
}


  /*
  */
  //std::cout << (x|ranges::view::all) << std::endl;

} // TEST CASE

/*
*/



/*

TEST_CASE( "313" ) {
  int lat = 1, jbeta = -7, iskip = 0;
  double enow = 1e-5, ep = 0.0, tev = 2.5507297688E-2;
  std::vector<double> betas { 0.1, 0.2, 1.3, 1.4, 2.5, 2.6, 3.7 }, x(20,0.0);


  GIVEN( "Various jbeta values, fixed enow" ){ 
    std::vector<int> jbetaVec(15), final_jbeta(15);
    std::vector<double> final_ep(15);

    jbetaVec    = ranges::view::iota(-7,8);
    final_jbeta = {1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7};
    final_ep    = {2.54e-3, 2.54e-3, 2.54e-3, 2.54e-3, 2.54e-3, 2.54e-3, 2.54e-3, 
                   2.54e-3, 2.54e-3, 5.07e-3, 3.29e-2, 3.543e-2, 6.326e-2, 
                   6.579e-2, 9.362e-2};
    enow = 1e-5;
    for ( size_t i = 0; i < jbetaVec.size(); ++i ){
      jbeta = jbetaVec[i];
      ep = do_313( lat, jbeta, enow, betas, x, tev );
      REQUIRE( final_jbeta[i] == jbeta );
      REQUIRE( final_ep[i] == Approx(ep).epsilon(1e-6) );
    }


    final_jbeta = {1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7};
    final_ep    = {3.53e-3, 3.53e-3, 3.53e-3, 3.53e-3, 3.53e-3, 3.53e-3, 3.53e-3, 
                   3.53e-3, 3.53e-3, 6.06e-3, 3.389e-2, 3.642e-2, 6.425e-2, 
                   6.678e-2, 9.461e-2};
    enow = 1e-3;
    for ( size_t i = 0; i < jbetaVec.size(); ++i ){
      jbeta = jbetaVec[i];
      ep = do_313( lat, jbeta, enow, betas, x, tev );
      REQUIRE( final_jbeta[i] == jbeta );
      REQUIRE( final_ep[i] == Approx(ep).epsilon(1e-6) );
    } 

    final_jbeta = {-7, -6, -5, -4, -3, -2, -1, 1, 1, 2, 3, 4, 5, 6, 7 };
    final_ep    = {6.39000153e-3, 3.4220001e-2, 3.6750001e-2, 6.4580001e-2, 
                   6.7110001e-2, 9.4940001e-2, 9.7470001e-2, 0.10253,  0.10253, 
                   0.10506, 0.13289, 0.13542, 0.16325, 0.16578, 0.19361 };
    enow = 1e-1;
    for ( size_t i = 0; i < jbetaVec.size(); ++i ){
      jbeta = jbetaVec[i];
      //std::cout << jbeta << std::endl;
      ep = do_313( lat, jbeta, enow, betas, x, tev );
      REQUIRE( final_jbeta[i] == jbeta );
      REQUIRE( final_ep[i] == Approx(ep).epsilon(1e-6) );
    } 

  } // GIVEN



} // TEST CASE
*/




/*

TEST_CASE( "E-E'-mu" ){
  REQUIRE( true );

  std::vector<double> alphas { 1.1, 2.2, 3.3, 4.5, 5.8 },
                       betas { 0.1, 0.2, 1.3, 1.4, 2.5, 2.6, 3.7 };
  std::vector<double> sab(alphas.size()*betas.size());
  for ( size_t i = 0; i < alphas.size(); ++i ){
    for ( size_t j = 0; j < betas.size(); ++j ){
      sab[i*betas.size()+j] = 0.01*((j+1) + 0.1*(i+1));
    } 
  } 
  double az = 0.99917, tol = 5e-2;
  int lasym = 0, lat = 1, iinc = 2, jmax = 55550;
  int nne = 88, nnl = -9, nl = 9;
  double T = 296.0, teff = 1397.671, teff2 = 0.0, sigma_b = 163.72792237360667, sigma_b2 = 0.0;

  std::cout.precision(15);

  e_ep_mu( T, teff, teff2, jmax, nne, nnl, nl, tol, sigma_b, sigma_b2, az, lasym, lat, iinc, alphas, betas, sab );


}
*/

