#include "catch.hpp"
#include "calcem/calcem_util/e_ep_mu_util/e_ep_mu.h"
#include <range/v3/all.hpp>
#include "generalTools/testing.h"
#include <range/v3/all.hpp>

template <typename RangeInt, typename Range, typename Float>
void checkFirstEprime( const RangeInt& jbetaVec, int lat, const Float& enow, const Range& betas, const Range& x, const Float& tev, const RangeInt& finalJbeta, const Range& finalEp ){
  int jbeta;
  Float ep;
  for ( size_t i = 0; i < jbetaVec.size(); ++i ){
    jbeta = jbetaVec[i];
    ep = findFirstEprime( lat, jbeta, enow, betas, x, tev );
    REQUIRE( finalJbeta[i] == jbeta );
    REQUIRE( finalEp[i] == Approx(ep).epsilon(1e-6) );
  }
}




/*

TEST_CASE( "do we need a midpoint" ){ 
  std::vector<double> x(20,0.0), y(20*65,0.0); 
  
  std::vector<double> initialY { 195158.09939262934, -0.87238772679496734, -0.61817875518802279, -0.36545660682035069, -0.11418564421716945, 0.13568062577950979, 0.38420180765640111, 0.63141488906433418, 0.87738226704862166 };

  x[0] = 2.54E-3;
  
  for (size_t i = 0; i < initialY.size(); ++i){ 
    y[i*x.size()+0] = initialY[i]; 
  }



  double xm = 1.27e-3;
  std::vector<double> s { 235586.48147822541, -0.86806816809249565, -0.60677324533223020, -0.34926974510882292, -9.5577908119815064E-002, 0.15436521665672856, 0.40054354740949549, 0.64302993119542795, 0.88181200416435501, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  int i = 2;
  int nl = 9;
  double tol = 1.0;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == false );
  tol = 1e-2;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == true  );
  tol = 5e-1;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == true  );
  tol = 0.56;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == true  );
  tol = 0.59;
  REQUIRE( needMidpoint(x,y,xm,i,nl,s,tol) == false );


} // TEST CASE


*/

TEST_CASE( "do 330" ){ 

  int imax = 20;
  std::vector<double> x(imax,0.0), y(imax*65,0.0), initialY { 194040.3395, 
                     -0.745374226, -0.240023402, 0.259736457, 0.754304965 };
  x[0] = 2.5607298E-3;
  for (size_t i = 0; i < initialY.size(); ++i){ y[i*x.size()+0] = initialY[i]; }

  int i = 2, lat = 0, iinc = 2, lasym = 0;
  double tev = 2.5507297688e-2, tol = 5.0E-2;
  double enow;
  std::vector<double> alphas { 1.1, 2.2, 3.3, 4.5, 5.8 },
                       betas { 0.1, 0.2, 1.3, 1.4, 2.5, 2.6, 3.7 },
                       sab { -0.18259619, -0.30201347, -3.93654779, -3.98809174, 
  -4.33545607, -4.39515402, -5.88934921, -0.76225291, -0.81658341, -3.14161459, 
  -3.30566186, -3.90554652, -3.96233362, -5.23696660, -1.19182884, -1.23155471, 
  -2.79610565, -2.95633099, -3.74989225, -3.80837585, -4.93373911, -1.58342860, 
  -1.61310713, -2.71233943, -2.84291608, -3.69699590, -3.75199349, -4.77433858, 
  -1.96121202, -1.98720663, -2.78454600, -2.88531460, -3.71288120, -3.77142141, 
  -4.71158392 };

  double az = 0.99917, sigma_b = 163.72792237, sigma_b2 = 0.0, teff = 0.120441926;
  int nnl = -5, nl = 5, jbeta = 1,j = 0;

  std::vector<double> scr(2*imax*65,0.0);
  int counter = 0;


  double ulast, u2last, u3last;
  std::vector<double> correctX(imax), pdf(imax), mu1(imax), mu2(imax), mu3(imax), mu4(imax);


  GIVEN( "Small initial energy (E=1e-5 eV)" ){
    enow = 1e-5;

    THEN( "Returned x values, y vector, and moment values are correct" ){
      auto out = do_330(enow,x,y,i,j,tev,tol,lat,iinc,lasym,alphas,betas,sab,az,sigma_b,sigma_b2,teff,nnl,nl,jbeta,scr);
      /*
      std::cout << scr[0] << std::endl;
      std::cout << scr[1] << std::endl;
      std::cout << scr[2] << std::endl;
      std::cout << scr[3] << std::endl;
      std::cout << scr[4] << std::endl;
      std::cout << scr[5] << std::endl;
      std::cout << scr[6] << std::endl;
      std::cout << scr[7] << std::endl;
      std::cout << scr[8] << std::endl;
      std::cout << scr[9] << std::endl;
      std::cout << scr[10] << std::endl;
      std::cout << scr[11] << std::endl;
      std::cout << scr[12] << std::endl;
      std::cout << scr[13] << std::endl;
      std::cout << scr[14] << std::endl;
      std::cout << scr[15] << std::endl;
      std::cout << scr[16] << std::endl;
      */

      ulast  = std::get<0>(out); REQUIRE( 2609.673 == Approx(ulast ).epsilon(1e-6));
      u2last = std::get<1>(out); REQUIRE(-6650.153 == Approx(u2last).epsilon(1e-6));
      u3last = std::get<2>(out); REQUIRE( 358.7471 == Approx(u3last).epsilon(1e-6));

      correctX = { 2.560729E-3, 1.920547E-3, 1.280364E-3, 3.200912E-4, 1.600456E-4, 
      8.002281E-5, 4.001140E-5, 2.000570E-5, 1.000285E-5, 5.001426E-6, 2.500713E-6, 
      1.250356E-6, 6.251782E-7, 3.125891E-7, 1.562945E-7, 7.814728E-8, 3.907364E-8, 
      1.953682E-8, 9.768411E-9, 0.0 };
      pdf = { 194040.3, 213357.4, 234616.8, 270904.3, 278088.3, 281762.2, 
           284435.9, 284849.7, 281681.0, 201641.8, 142771.2, 100595.0, 71050.27, 
           50112.44, 35395.39, 25015.29, 17684.03, 12502.95, 8840.380, 0.0};
      mu1 = {     -0.7453742, -0.7422468, -0.7375231, -0.7158896, -0.6992124, 
      -0.6768329, -0.6449507, -0.6021970, -0.5463158, -0.6019580, -0.6442864, 
      -0.6756062, -0.6972283, -0.7129893, -0.7239285, -0.7315982, -0.7369996, 
      -0.7408188, -0.7435070, 0.00000000 };
      mu2 = {      -0.24002340, -0.23307917, -0.22265027, -0.17496084, -0.13820280, 
      -0.08941394, -0.02005056,  0.07379239,  0.19662745,  0.07431822, -0.01860502, 
      -0.08672420, -0.13381656, -0.16855131, -0.19263496, -0.20951361, -0.22139824, 
      -0.22977689, -0.23570553,  0.0 };
      mu3 = {    0.2597364, 0.2667551, 0.2772268, 0.3250109, 0.3618243, 0.4093513, 
      0.4769398, 0.5740460, 0.6965196, 0.5745724, 0.4783592, 0.4120090, 0.3662356, 
      0.3314537, 0.3073638, 0.2904852, 0.2786010, 0.2702225, 0.2643070, 0.0 };
      mu4 = {    0.7543049, 0.7574966, 0.7623170, 0.7840282, 0.8005880, 0.8224674, 
      0.8530495, 0.8969429, 0.9528127, 0.8971790, 0.8537006, 0.8236852, 0.8025615, 
      0.7869531, 0.7760527, 0.7683948, 0.7629976, 0.7591794, 0.7564790, 0.0 };

      REQUIRE( 1  == i );
      REQUIRE( 20 == j );
      REQUIRE( 2  == jbeta );

      REQUIRE( ranges::equal(x,correctX,equal) );
      std::vector<std::vector<double>> correct { pdf, mu1, mu2, mu3, mu4 };
      for ( size_t i = 0; i < correct.size(); ++i ){
        for ( size_t j = 0; j < correct[i].size(); ++j ){
          REQUIRE( correct[i][j] == Approx(y[i*x.size()+j]).epsilon(1e-6) );
        }
      }
      for ( size_t i = correct.size()*x.size(); i < y.size(); ++i){
        REQUIRE( 0.0 == Approx(y[i]).epsilon(1e-6) );
      }

      std::vector<double> correctSCR { 0.0, 0.0, 0.0, 0.0, 0.0, 9.768411E-9, 
      8.8403807E3,-7.435070E-1,-2.357055E-1, 2.643070E-1, 7.564790E-1, 1.953682E-8, 
      1.2502953E4,-7.408188E-1,-2.297769E-1, 2.702225E-1, 7.591794E-1, 3.907364E-8, 
      1.7684034E4,-7.369996E-1,-2.213982E-1, 2.786010E-1, 7.629976E-1, 7.814728E-8, 
      2.5015295E4,-7.315982E-1,-2.095136E-1, 2.904852E-1, 7.683948E-1, 1.562945E-7, 
      3.5395394E4,-7.239285E-1,-1.926349E-1, 3.073638E-1, 7.760527E-1, 3.125891E-7, 
      5.0112448E4,-7.129893E-1,-1.685513E-1, 3.314537E-1, 7.869531E-1, 6.251782E-7, 
      7.1050277E4,-6.972283E-1,-1.338165E-1, 3.662356E-1, 8.025615E-1, 1.250356E-6, 
      1.0059506E5,-6.756062E-1,-8.672421E-2, 4.120090E-1, 8.236852E-1, 2.500713E-6, 
      1.4277126E5,-6.442864E-1,-1.860502E-2, 4.783592E-1, 8.537006E-1, 5.001426E-6, 
      2.0164182E5,-6.019580E-1, 7.431822E-2, 5.745724E-1, 8.971790E-1, 1.000285E-5, 
      2.8168109E5,-5.463158E-1, 1.966274E-1, 6.965196E-1, 9.528127E-1, 2.000570E-5, 
      2.8484972E5,-6.021970E-1, 7.379239E-2, 5.740460E-1, 8.969429E-1, 4.001140E-5, 
      2.8443599E5,-6.449507E-1,-2.005056E-2, 4.769398E-1, 8.530495E-1, 8.002281E-5, 
      2.8176229E5,-6.768329E-1,-8.941394E-2, 4.093513E-1, 8.224674E-1, 1.600456E-4, 
      2.7808831E5,-6.992124E-1,-1.382028E-1, 3.618243E-1, 8.005880E-1, 3.200912E-4, 
      2.7090434E5,-7.158896E-1,-1.749608E-1, 3.250109E-1, 7.840282E-1, 6.401824E-4, 
      2.5808226E5,-7.280949E-1,-2.018525E-1, 2.980850E-1, 7.718158E-1, 1.280364E-3, 
      2.3461686E5,-7.375232E-1,-2.226502E-1, 2.772268E-1, 7.623170E-1, 1.920547E-3, 
      2.1335745E5,-7.422468E-1,-2.330791E-1, 2.667551E-1, 7.574966E-1 };

        for ( size_t i = 0; i < correctSCR.size(); ++i ){
          REQUIRE( scr[i] == Approx(correctSCR[i]).epsilon(1e-6) );
        }

    } // THEN
  } // GIVEN



  GIVEN( "Medium initial energy (E=1e-3 eV)" ){
    enow = 1e-3;

    THEN( "Returned x values, y vector, and moment values are correct" ){

      auto out = do_330(enow,x,y,i,j,tev,tol,lat,iinc,lasym,alphas,betas,sab,az,sigma_b,sigma_b2,teff,nnl,nl,jbeta,scr);

      ulast  = std::get<0>(out); REQUIRE( 2993.879 == Approx(ulast ).epsilon(1e-6));
      u2last = std::get<1>(out); REQUIRE(-240.7431 == Approx(u2last).epsilon(1e-6));
      u3last = std::get<2>(out); REQUIRE( 427.3755 == Approx(u3last).epsilon(1e-6));
  

      correctX = { 2.5607298E-3, 2.5607297E-3, 2.5607295E-3, 6.4018245E-4, 
      1.6004562E-4, 8.0022810E-5, 4.0011405E-5, 2.0005703E-5, 1.0002852E-5, 
      5.0014260E-6, 2.5007130E-6, 1.2503565E-6, 6.2517825E-7, 3.1258913E-7, 
      1.5629457E-7, 7.8147285E-8, 3.9073643E-8, 1.9536822E-8, 9.7684110E-9, 0.0 };
      pdf = { 194040.3, 22928.53, 22928.53, 22004.47, 10421.57, 7271.812, 
      5109.760, 3602.049, 2543.152, 1796.915, 1270.129, 897.9471, 634.8844, 
      448.9098, 317.4197, 224.4469, 158.7070, 112.2224, 79.35316, 0.0 };
      mu1 = {      -0.7453742, -0.6639123, -0.6639123, -0.5966787, -0.6825695, 
      -0.7041852,  -0.7182603, -0.7278000, -0.7343954, -0.7390024, -0.7422431, 
      -0.7445198,  -0.7461270, -0.7472623, -0.7480646, -0.7486316, -0.7490325, 
      -0.7493159,  -0.7495163, 0.0 };
      mu2 = {      -0.24002340, -0.06436183, -0.06436181, 0.08567835, -0.10222948, 
      -0.14962484, -0.18042466, -0.20130111, -0.21574559, -0.22584518, -0.23293962, 
      -0.23794773, -0.24148212, -0.24397868, -0.24574300, -0.24699014, -0.24787184, 
      -0.24849522, -0.24893599, 0.0 };
      mu3 = {    0.2597364, 0.4272364, 0.4272364, 0.5853635, 0.3965669, 0.3496719, 
      0.3192034, 0.2985083, 0.2841580, 0.2741063, 0.2670555, 0.2620485, 0.2585157, 
      0.2560201, 0.2542564, 0.2530096, 0.2521280, 0.2515047, 0.2510640, 0.0 };
      mu4 = {    0.7543049, 0.8233353, 0.8233353, 0.9011784, 0.8153225, 0.7947936, 
      0.7812307, 0.7719456, 0.7654775, 0.7609340, 0.7577044, 0.7554555, 0.7538610, 
      0.7527317, 0.7519323, 0.7513667, 0.7509666, 0.7506835, 0.7504834, 0.0 };

      REQUIRE( 1  == i );
      REQUIRE( 43 == j );
      REQUIRE( 2  == jbeta );


      REQUIRE( ranges::equal(x,correctX,equal) );
      std::vector<std::vector<double>> correct { pdf, mu1, mu2, mu3, mu4 };
      for ( size_t i = 0; i < correct.size(); ++i ){
        for ( size_t j = 0; j < pdf.size(); ++j ){
          REQUIRE( correct[i][j] == Approx(y[i*x.size()+j]).epsilon(1e-6) );
        }
      }
      for ( size_t i = correct.size()*x.size(); i < y.size(); ++i){
        REQUIRE( 0.0 == Approx(y[i]).epsilon(1e-6) );
      }
  
      std::vector<double> correctSCR {0.0,  0.0,  0.0,  0.0,  0.0,  9.7684110E-9,  
      7.935317E1, -7.495163E-1, -2.489359E-1,  2.510640E-1,  0.7504834,  1.953682E-8,  
      1.122224E2, -7.493159E-1, -2.484952E-1,  2.515047E-1,  0.7506835,  3.907364E-8,  
      1.587070E2, -7.490325E-1, -2.478718E-1,  2.521281E-1,  0.7509666,  7.814728E-8,  
      2.244469E2, -7.486316E-1, -2.469901E-1,  2.530096E-1,  0.7513667,  1.562945E-7,  
      3.174197E2, -7.480646E-1, -2.457430E-1,  2.542564E-1,  0.7519323,  3.125891E-7,  
      4.489098E2, -7.472623E-1, -2.439786E-1,  2.560201E-1,  0.7527317,  6.251782E-7,  
      6.348844E2, -7.461270E-1, -2.414821E-1,  2.585157E-1,  0.7538610,  1.250356E-6,  
      8.979471E2, -7.445198E-1, -2.379477E-1,  2.620485E-1,  0.7554555,  2.500713E-6,  
      1.270129E3, -7.422431E-1, -2.329396E-1,  2.670555E-1,  0.7577044,  5.001426E-6,  
      1.796915E3, -7.390024E-1, -2.258451E-1,  2.741063E-1,  0.7609340,  1.000285E-5,  
      2.543152E3, -7.343954E-1, -2.157456E-1,  2.841580E-1,  0.7654776,  2.000570E-5,  
      3.602049E3, -7.278000E-1, -2.013011E-1,  2.985083E-1,  0.7719456,  4.001140E-5,  
      5.109760E3, -7.182603E-1, -1.804246E-1,  3.192034E-1,  0.7812307,  8.002281E-5,  
      7.271812E3, -7.041852E-1, -1.496248E-1,  3.496719E-1,  0.7947936,  1.600456E-4,  
      1.042157E4, -6.825695E-1, -1.022294E-1,  3.965669E-1,  0.8153225,  3.200912E-4,  
      1.505175E4, -6.496485E-1, -3.072243E-2,  4.657100E-1,  0.8468844,  6.401824E-4,  
      2.200447E4, -5.966787E-1,  8.567835E-2,  5.853635E-1,  0.9011784,  9.602736E-4,  
      2.786274E4, -5.468695E-1,  1.954414E-1,  6.954181E-1,  0.9523540,  1.280364E-3,  
      2.744101E4, -5.771819E-1,  1.285756E-1,  6.282528E-1,  0.9211990,  1.920547E-3,  
      2.500692E4, -6.313135E-1,  8.429071E-3,  5.050226E-1,  0.8609199,  2.240638E-3,  
      2.378573E4, -6.513582E-1, -3.717092E-2,  0.4529485, 0.8359541,  2.400684E-3,  
      2.346375E4, -6.564133E-1, -4.759721E-2,  0.4444134, 0.8318966,  2.480707E-3,  
      2.319436E4, -6.602429E-1, -5.614899E-2,  0.4356622, 0.8275429,  2.520718E-3,  
      2.306101E4, -6.620969E-1, -6.029621E-2,  0.4314102, 0.8254215,  2.540724E-3,  
      2.299466E4, -6.630093E-1, -6.233904E-2,  0.4293137, 0.8243741,  2.550727E-3,  
      2.296156E4, -6.634620E-1, -6.335292E-2,  0.4282727, 0.8238536,  2.555728E-3,  
      2.294504E4, -6.636874E-1, -6.385800E-2,  0.4277539, 0.8235942,  2.558229E-3,  
      2.293678E4, -6.637999E-1, -6.411007E-2,  0.4274950, 0.8234647,  2.559479E-3,  
      2.293265E4, -6.638561E-1, -6.423600E-2,  0.4273657, 0.8234000,  2.560104E-3,  
      2.293059E4, -6.638842E-1, -6.429893E-2,  0.4273010, 0.8233676,  2.560417E-3,  
      2.292956E4, -6.638983E-1, -6.433039E-2,  0.4272687, 0.8233514,  2.560573E-3,  
      2.292904E4, -6.639053E-1, -6.434612E-2,  0.4272525, 0.8233434,  2.560651E-3,  
      2.292878E4, -6.639088E-1, -6.435398E-2,  0.4272445, 0.8233393,  2.560690E-3,  
      2.292865E4, -6.639105E-1, -6.435791E-2,  0.4272404, 0.8233373,  2.560710E-3,  
      2.292859E4, -6.639114E-1, -6.435988E-2,  0.4272384, 0.8233363,  2.560720E-3,  
      2.292856E4, -6.639119E-1, -6.436086E-2,  0.4272374, 0.8233358,  2.560725E-3,  
      2.292854E4, -6.639121E-1, -6.436136E-2,  0.4272369, 0.8233355,  2.560727E-3,  
      2.292853E4, -6.639122E-1, -6.436160E-2,  0.4272366, 0.8233354,  2.560728E-3,  
      2.292853E4, -6.639122E-1, -6.436172E-2,  0.4272365, 0.8233353,  2.560729E-3,  
      2.292853E4, -6.639123E-1, -6.436178E-2,  0.4272365, 0.8233353,  2.560729E-3,  
      2.292853E4, -6.639123E-1, -6.436181E-2,  0.4272364, 0.8233353,  2.560729E-3,  
      2.292853E4, -6.639123E-1, -6.436183E-2,  0.4272364, 0.8233353,  0.0,  0.0};
        for ( size_t i = 0; i < correctSCR.size(); ++i ){
          REQUIRE( scr[i] == Approx(correctSCR[i]).epsilon(1e-6) );
          //  std::cout << scr[i] << std::endl;
        }






    } // THEN 
  } // GIVEN

  /*

*/
} // TEST CASE


TEST_CASE( "313" ) {
  int lat = 1, jbeta = -7;
  double enow, ep, tev = 2.5507297688E-2;
  std::vector<double> betas { 0.1, 0.2, 1.3, 1.4, 2.5, 2.6, 3.7 }, x(20,0.0);


  GIVEN( "Various jbeta values, fixed enow" ){ 
    std::vector<int> jbetaVec(15), finalJbeta(15);
    std::vector<double> finalEp(15);

    jbetaVec    = ranges::view::iota(-7,8);

    enow = 1e-5;
    finalJbeta = {1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7};
    finalEp    = {2.54e-3, 2.54e-3, 2.54e-3, 2.54e-3, 2.54e-3, 2.54e-3, 2.54e-3, 
                   2.54e-3, 2.54e-3, 5.07e-3, 3.29e-2, 3.543e-2, 6.326e-2, 
                   6.579e-2, 9.362e-2};
    checkFirstEprime( jbetaVec, lat, enow, betas, x, tev, finalJbeta, finalEp );


    enow = 1e-3;
    finalJbeta = {1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7};
    finalEp    = {3.53e-3, 3.53e-3, 3.53e-3, 3.53e-3, 3.53e-3, 3.53e-3, 3.53e-3, 
                  3.53e-3, 3.53e-3, 6.06e-3, 3.389e-2, 3.642e-2, 6.425e-2, 
                  6.678e-2, 9.461e-2};
    checkFirstEprime( jbetaVec, lat, enow, betas, x, tev, finalJbeta, finalEp );


    enow = 1e-1;
    finalJbeta = {-7, -6, -5, -4, -3, -2, -1, 1, 1, 2, 3, 4, 5, 6, 7 };
    finalEp    = {6.39000153e-3, 3.4220001e-2, 3.6750001e-2, 6.4580001e-2, 
                  6.7110001e-2, 9.4940001e-2, 9.7470001e-2, 0.10253,  0.10253, 
                  0.10506, 0.13289, 0.13542, 0.16325, 0.16578, 0.19361 };
    checkFirstEprime( jbetaVec, lat, enow, betas, x, tev, finalJbeta, finalEp );

  } // GIVEN



} // TEST CASE

/*
*/









TEST_CASE( "do 330 (and some things around it)" ){ 

  int imax = 20;
  std::vector<double> x(imax,0.0), y(imax*65,0.0), initialY { 194040.3395, 
                     -0.745374226, -0.240023402, 0.259736457, 0.754304965 };
  x[0] = 2.5607298E-3;
  for (size_t i = 0; i < initialY.size(); ++i){ y[i*x.size()+0] = initialY[i]; }

  int lat = 0, iinc = 2, lasym = 0;
  double tev = 2.5507297688e-2, tol = 5.0E-2;
  double enow = 1e-5;
  std::vector<double> alphas { 1.1, 2.2, 3.3, 4.5, 5.8 },
                       betas { 0.1, 0.2, 1.3, 1.4, 2.5, 2.6, 3.7 },
                       sab {-0.18259619, -0.30201347, -3.93654779, -3.98809174, 
  -4.33545607, -4.39515402, -5.88934921, -0.76225291, -0.81658341, -3.14161459, 
  -3.30566186, -3.90554652, -3.96233362, -5.23696660, -1.19182884, -1.23155471, 
  -2.79610565, -2.95633099, -3.74989225, -3.80837585, -4.93373911, -1.58342860, 
  -1.61310713, -2.71233943, -2.84291608, -3.69699590, -3.75199349, -4.77433858, 
  -1.96121202, -1.98720663, -2.78454600, -2.88531460, -3.71288120, -3.77142141, 
  -4.71158392 };

  double az = 0.99917, sigma_b = 163.72792237, sigma_b2 = 0.0, teff = 0.120441926;
  int nnl = -5, nl = 5, jbeta = 1,j = 0;

  std::vector<double> scr(65*imax*8,0.0);

  do_330_extra(enow,j,tev,tol,lat,iinc,lasym,alphas,betas,sab,az,sigma_b,sigma_b2,teff,nnl,nl,jbeta,scr);

  std::vector<double> correctSCR {0.0, 0.0, 0.0, 0.0, 0.0, 9.768411E-9, 
      4.428672E0, -7.435070E-1, -2.357055E-1, 0.26430706, 0.75647904, 1.953682E-8, 
      6.263472E0, -7.408188E-1, -2.297769E-1, 0.27022259, 0.75917947, 3.907364E-8, 
      8.858983E0, -7.369996E-1, -2.213982E-1, 0.27860108, 0.76299763, 7.814729E-8, 
      1.253165E1, -7.315983E-1, -2.095136E-1, 2.904852E-1, 0.76839487, 1.562946E-7, 
      1.773166E1, -7.239286E-1, -1.926350E-1, 0.30736385, 0.77605279, 3.125891E-7, 
      2.510430E1, -7.129893E-1, -1.685513E-1, 0.33145375, 0.78695311, 6.251783E-7, 
      3.559330E1, -6.972284E-1, -1.338166E-1, 0.36623567, 0.80256153, 1.250357E-6, 
      5.039404E1, -6.756062E-1, -8.672421E-2, 0.41200901, 0.82368525, 2.500713E-6, 
      7.152261E1, -6.442864E-1, -1.860503E-2, 0.47835921, 0.85370067, 5.001426E-6, 
      1.010144E2, -6.019581E-1, 7.431823E-2, 0.57457246, 8.971790E-1, 1.000285E-5, 
      1.411108E2, -5.463158E-1, 0.19662746, 0.69651961, 9.528127E-1, 2.000570E-5, 
      1.426981E2, -6.021971E-1, 7.379239E-2, 0.57404606, 0.89694298, 4.001141E-5, 
      1.424909E2, -6.449508E-1, -2.005056E-2, 0.47693985, 0.85304958, 8.002281E-5, 
      1.411515E2, -6.768329E-1, -8.941395E-2, 0.40935137, 0.82246748, 1.600456E-4, 
      1.393110E2, -6.992125E-1, -1.382028E-1, 0.36182434, 0.80058802, 3.200912E-4, 
      1.357121E2, -7.158896E-1, -1.749608E-1, 0.32501093, 0.78402829, 6.401825E-4, 
      1.292887E2, -7.280950E-1, -2.018526E-1, 0.29808506, 0.77181586, 1.280365E-3, 
      1.175335E2, -7.375232E-1, -2.226503E-1, 0.27722683, 0.76231708, 1.920547E-3, 
      1.068834E2, -7.422468E-1, -2.330792E-1, 0.26675518, 0.75749668, 2.560730E-3, 
      9.720633E1, -7.453742E-1, -2.400234E-1, 0.25973646, 0.75430497, 3.198412E-3, 
      8.844101E1, -7.477164E-1, -2.452313E-1, 0.25446347, 0.75188839, 3.836095E-3, 
      8.046737E1, -7.496037E-1, -2.494359E-1, 0.25019686, 0.74992331, 5.111460E-3, 
      6.661351E1, -7.525702E-1, -2.560654E-1, 0.24344522, 0.74679907, 5.111567E-3, 
      4.863349E1, -7.500001E-1, -2.500002E-1, 0.24999982, 0.74999992, 5.111674E-3, 
      4.863286E1, -7.500002E-1, -2.500004E-1, 0.24999964, 0.74999984, 5.111888E-3, 
      4.863160E1, -7.500003E-1, -2.500007E-1, 0.24999929, 0.74999967, 5.112316E-3, 
      4.862909E1, -7.500006E-1, -2.500014E-1, 0.24999857, 0.74999934, 5.113172E-3, 
      4.862405E1, -7.500013E-1, -2.500028E-1, 0.24999714, 0.74999869, 5.114885E-3, 
      4.861399E1, -7.500025E-1, -2.500056E-1, 0.24999429, 0.74999737, 5.118310E-3, 
      4.859387E1, -7.500051E-1, -2.500113E-1, 0.24998858, 0.74999474, 5.125160E-3, 
      4.855364E1, -7.500101E-1, -2.500225E-1, 0.24997717, 0.74998949, 5.138860E-3, 
      4.847326E1, -7.500202E-1, -2.500450E-1, 2.499544E-1, 0.74997901, 5.166260E-3, 
      4.831283E1, -7.500403E-1, -2.500897E-1, 0.24990905, 0.74995812, 5.221061E-3, 
      4.799323E1, -7.500801E-1, -2.501784E-1, 0.24981905, 0.74991669, 5.330663E-3, 
      4.735917E1, -7.501585E-1, -2.503531E-1, 0.24964185, 7.498351E-1, 5.549866E-3, 
      4.611191E1, -7.503107E-1, -2.506922E-1, 2.492980E-1, 7.496768E-1, 5.988273E-3, 
      4.370278E1, -7.505983E-1, -2.513328E-1, 0.24864845, 0.74937774, 6.865086E-3, 
      3.923052E1, -7.511177E-1, -2.524895E-1, 0.24747558, 0.74883772, 8.618713E-3, 
      3.160939E1, -7.519948E-1, -2.544435E-1, 0.24549408, 0.74792514, 1.212597E-2, 
      2.069604E1, -7.533613E-1, -2.574904E-1, 0.24240123, 0.74649937, 1.563322E-2, 
      1.377782E1, -7.544366E-1, -2.598920E-1, 0.23995895, 0.74537162, 1.914047E-2, 
      9.333232E0, -7.553412E-1, -2.619156E-1, 2.378971E-1, 0.74441781, 2.264773E-2, 
      6.427451E0, -7.561320E-1, -2.636877E-1, 0.23608797, 0.74357938, 2.615498E-2, 
      4.494250E0, -7.568408E-1, -2.652788E-1, 0.23446062, 0.74282387, 2.966223E-2, 
      3.156512E0, -7.563538E-1, -2.641408E-1, 0.23567667, 0.74341138, 3.316949E-2, 
      2.258159E0, -7.578482E-1, -2.675061E-1, 0.23222259, 0.74180269, 3.572022E-2, 
      2.205466E0, -7.566034E-1, -2.647018E-1, 2.351020E-1, 0.74314423, 4.974923E-2, 
      2.144491E0, -7.542702E-1, -2.594970E-1, 0.24038819, 0.74558222, 5.676374E-2, 
      1.880905E0, -7.526384E-1, -2.559083E-1, 0.24390065, 7.470732E-1, 6.377824E-2, 
      1.561732E0, -7.520956E-1, -2.546458E-1, 0.24531479, 0.74785391, 6.632897E-2, 
      1.452495E0, -7.519976E-1, -2.544288E-1, 0.24553334, 0.74795393, 8.035799E-2, 
      8.258413E-1, -7.520148E-1, -2.544723E-1, 0.24548373, 0.74792881, 8.737250E-2, 
      5.720349E-1, -7.520276E-1, -2.544978E-1, 0.24546106, 7.479197E-1, 9.438700E-2, 
      0.0, 0.0, 0.0, 0.0, 0.0 } ;

        for ( size_t i = 0; i < correctSCR.size(); ++i ){
          if ( (i) % 6 == 0 ){ continue; } // This is because I still don't really
          // know what that one entry is that appears second in each scr piece
          REQUIRE( scr[i] == Approx(correctSCR[i]).epsilon(1e-6) );
          //  std::cout << scr[i] << std::endl;
        }





} // TEST CASE

/*

*/




















/*

TEST_CASE( "E-E'-mu" ){
  REQUIRE( true );

  std::vector<double> alphas { 1.1, 2.2, 3.3, 4.5, 5.8 },
                       betas { 0.1, 0.2, 1.3, 1.4, 2.5, 2.6, 3.7 };
  std::vector<double> sab(alphas.size()*betas.size());
  for ( size_t i = 0; i < alphas.size(); ++i ){
    for ( size_t j = 0; j < betas.size(); ++j ){
      sab[i*betas.size()+j] = 0.01*((j+1) + 0.1*(i+1));
    } 
  } 
  double az = 0.99917, tol = 5e-2;
  int lasym = 0, lat = 1, iinc = 2, jmax = 55550;
  int nne = 88, nnl = -9, nl = 9;
  double T = 296.0, teff = 1397.671, teff2 = 0.0, sigma_b = 163.72792237360667, sigma_b2 = 0.0;

  std::cout.precision(15);

  e_ep_mu( T, teff, teff2, jmax, nne, nnl, nl, tol, sigma_b, sigma_b2, az, lasym, lat, iinc, alphas, betas, sab );


}
*/

